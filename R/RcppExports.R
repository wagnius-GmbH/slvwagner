# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Flugbahn
#'
#' @name Flugbahn
#' @description Berechnet die Flugbahn eines Geschosses mit berücksichtigung des Luftwiderstandes.
#' Es wird über den Zeitintervall "t" dv, und dx,dy berechnet.
#' @usage Flugbahn(v0,t,angle, target_vector, m, k,nb_return_values)
#' @param v0 Geschosss-Geschwindigkeit Vektor
#' @param t Zeit (interval der Berechnung)
#' @param angle Schusswinkel
#' @param target_vector target_vectorvektor
#' @param m Masse des Geschosses
#' @param k k-Wert = 0.5*cw*rho*A: cw ==> Strömungswiderstandskoeffizient, Widerstandsbeiwert, rho ==> Dichte (kg/m^3), A ==> Fläche (m^2);
#' @param nb_return_values Anzahl Werte die zurückgegeben werden. Wenn Null gewählt wird dann werden alle brechneten Werte zurückgegenen.
#' @return matrix
#' @examples # target_vector
#' @examples target_vector <- c(100, 20) # m
#' @examples angle <- atan(target_vector[2]/target_vector[1]) #rad
#' @examples # Zeitintervall
#' @examples t <- 1e-5
#' @examples # Geschoss
#' @examples v0 = 55 # [m/s]
#' @examples m <- 0.440 # [kg]
#' @examples cw <- 0.18; # cw Wert des Geschosses (Nach Tabellen der Geschossform)
#' @examples rho <- 1.293 # Dichte des Mediums (Luft) [kg/m^3]
#' @examples A <- (0.22)^2*pi/4 #Projektions Flaeche in Flugrichtung [m^2]
#' @examples k <- 0.5*cw*rho*A
#' @examples Flugbahn_c <- Flugbahn(v0,t,angle,target_vector,m,k,1000)[,4:5]
#' @examples colnames(Flugbahn_c) <- c("sx","sy")
#' @examples Flugbahn_c|>
#' @examples   plot(type = "l")
#' @examples #tidyvers
#' @examples library(tidyverse)
#' @examples Flugbahn_c|>
#' @examples   as_tibble()|>
#' @examples   ggplot(aes(sx,sy))+
#' @examples   geom_line()+
#' @examples   geom_point(data = tibble(x = target_vector[1],y = target_vector[2]),aes(x,y), color = "red")+
#' @examples   geom_text(aes(x = target_vector[1],y = target_vector[2]*1.1, label = "target_vector"))+
#' @examples   coord_fixed()+
#' @examples   labs(title = "Flugbahn Rcpp", subtitle = paste("v0:",v0,"\nt:",t))
#' @return matrix t,v_x, v_y, s_x, s_y, distance (to target)
#' @export
NULL

Flugbahn <- function(v0, t, angle, target_vector, m, k, nb_return_values) {
    .Call(`_slvwagner_Flugbahn`, v0, t, angle, target_vector, m, k, nb_return_values)
}

#' pendulum_motion
#'
#' @name pendulum_motion
#' @description Motion of pendulum.
#' @param L Länge des Pendels (m)
#' @param delta_t (s)
#' @param THETA_0 Startwinkel (rad)
#' @param THETA_DOT_0 Anfangsgeschwindigkeit (m/s^2)
#' @param mu Reibungkoeffizient
#' @param calculation_stop Abbruch wenn die Geschwindigkeit kleiner und der Winkel kleiner als calculation_stop
#' @param nb_return_values Anzahl Werte die zurückgegeben werden. Wenn Null gewählt wird dann werden alle brechneten Werte zurückgegenen.
#' @return matrix
#' @examples t = 35 ;
#' @examples L = 2; delta_t = 1e-5; THETA_0 = pi/3; THETA_DOT_0 = 3; mu = 0.1;
#' @examples calculation_stop = 0.05; nb_return_values = 800 ;
#' @examples pendulum_motion(L, delta_t, THETA_0, THETA_DOT_0, mu, calculation_stop, nb_return_values)|>
#' @examples plot(type = "l", main = "RccpTest: Pendulum Motion",xlab = "t", ylab = "angle")
#' @examples pendulum_motion(L, delta_t, THETA_0, THETA_DOT_0, mu, calculation_stop, nb_return_values)[,c(1,3)]|>
#' @examples plot(type = "l", main = "RccpTest: Pendulum Motion",xlab = "t", ylab = "angular velosity")
#' @export
NULL

pendulum_motion <- function(L, delta_t, THETA_0, THETA_DOT_0, mu, calculation_stop, nb_return_values) {
    .Call(`_slvwagner_pendulum_motion`, L, delta_t, THETA_0, THETA_DOT_0, mu, calculation_stop, nb_return_values)
}

#' @name cufft
#' @title Perform a 1D FFT using CUFFT
#' @description This function uses CUDA's CUFFT library to compute the 1D FFT on a given set of data.
#' @param n Integer. The number of elements in the FFT.
#' @param inverse Logical. Whether to compute the inverse FFT (TRUE) or forward FFT (FALSE).
#' @param h_idata_re Numeric vector. The real part of the input data.
#' @param h_idata_im Numeric vector. The imaginary part of the input data.
#' @param h_odata_re Numeric vector. The real part of the output data.
#' @param h_odata_im Numeric vector. The imaginary part of the output data.
#' @return A list with the real and imaginary parts of the transformed data.
#' @export
NULL

cufft <- function(n, inverse, h_idata_re, h_idata_im, h_odata_re, h_odata_im) {
    invisible(.Call(`_slvwagner_cufft`, n, inverse, h_idata_re, h_idata_im, h_odata_re, h_odata_im))
}

#' find_edges_2D
#' @name find_edges_2D
#' @title find_edges_2D
#' @description Finds edges in an evenly spaced 2D grid.
#' @details Checks all neighbour indices in a vector \code{c_search} for \code{TRUE}. If all neighbours are \code{TRUE} it is not an edge, else it is.
#' @param c_search Logical vector
#' @param n_col x direction of the matrix
#' @return logical vector if edge was found
#' @examples
#' n_col <- 7
#' n_row <- 4
#' c_search <- c(
#'   0,1,0,0,0,1,0,
#'   1,1,1,1,1,1,1,
#'   0,1,0,1,1,1,1,
#'   0,0,1,1,1,1,1
#'   )
#' m_grid <- expand.grid(x = 0:(n_col-1), y = 0:(n_row-1))|>
#'   as.matrix()|>
#'   cbind(c_search)
#' m_grid|>
#' head()
#' m_grid|>
#' plot(col = m_grid[,"c_search"],
#'   xlim=c(0,n_col-1), ylim=c(0,n_row-1),
#'   pch = 19,
#'   cex = 2.5,
#'   main = "Input: c_search")
#'
#' m_grid <- cbind(m_grid,
#'                 edge = find_edges_2D(m_grid[,"c_search"], n_col))
#'
#' m_grid|>
#'   head()
#' m_grid|>
#'   plot(col = m_grid[,"edge"],
#'        xlim=c(0,n_col-1), ylim=c(0,n_row-1),
#'        pch = 19,
#'        cex = 2.5,
#'        main = "Edge")
#' @export
NULL

find_edges_2D <- function(c_search, n_col) {
    .Call(`_slvwagner_find_edges_2D`, c_search, n_col)
}

#' @name find_edges_3D
#' @title Find edges in an evenly spaced 3D grid.
#' @description Checks all neighbour indices in a vector \code{c_search} for \code{TRUE}. If all neighbours are \code{TRUE} it is not an edge, else it is.
#' @param c_search Logical vector
#' @param n dimensions of 3D array c(nx, ny, nz)
#' @return logical vector if edge was found
#' @examples
#' n <- c(6L,5L,4L)
#' df_input <- expand.grid(
#'   x = 1:n[1],
#'   y = 1:n[2],
#'   z = 1:n[3])
#' df_input$search <- TRUE
#' df_input$edge <- find_edges_3D(df_input$search, n)
#' df_input$color <- ifelse(df_input$edge, "blue", "black")
#'
#' df_input
#' df_input|>
#'   rgl::plot3d(col = df_input$color, size = 15,aspect = "iso")
#'
#' @export
NULL

find_edges_3D <- function(c_search, n) {
    .Call(`_slvwagner_find_edges_3D`, c_search, n)
}

#' f_ableitung
#' @name f_ableitung
#' @title f_ableitung
#' @description Berechntet die Funktionswerte von f(x) = y = -1 + 2*x + 5*x^4.
#' @usage f_ableitung(x)
#' @param x vector
#' @examples f_ableitung(1+2i)
#' @export
NULL

#' f
#' @name f
#' @title f
#' @description Berechntet die Funktionswerte der Funktion f(x) = y = -0.2 - x + x^2 + x^5.
#' @usage f(x)
#' @param x vector
#' @examples f(1+2i)
#' @export
NULL

#' f_vector
#' @name f_vector
#' @title f_vector
#' @description Berechntet die Funktionswerte eines Polynoms.
#' @usage f_vector(x)
#' @param x vector
#' @examples f_vector(c(1+2i,-0.2-0.8i))
#' @export
NULL

#' f_ableitung_vector
#' @name f_ableitung_vector
#' @title f_ableitung_vector
#' @description Berechntet die Funktionswerte eines Polynoms.
#' @usage f_ableitung_vector(x)
#' @param x vector
#' @examples f_ableitung_vector(c(1+2i,-0.2-0.8i))
#' @export
NULL

#'
#' @name function_calc_complex
#' @title function_calc_complex
#' @description Berechntet die Funktionswerte eines Polynoms.
#' @usage function_calc_complex(x,poly)
#' @param x vector
#' @param poly polynom vector
#' @examples function_calc_complex(1+2i,
#' @examples polynom::polynomial(coef = c(-0.2, -1.0, 1.0, 0.0, 0.0, 1.0)))|>plot()
#' @export
NULL

#'
#' @name vector_function_calc_complex
#' @title vector_function_calc_complex
#' @description Berechntet die Funktionswerte eines Polynoms für gegebenen Vektor.
#' @usage vector_function_calc_complex(x,poly)
#' @param x vector
#' @param poly polynom vector
#' @examples vector_function_calc_complex(-6:6,
#' @examples polynom::polynomial(coef = c(-0.2, -1.0, 1.0, 0.0, 0.0, 1.0)))|>plot()
#' @export
NULL

#'
#' find roots
#' @name find_roots
#' @title find_roots
#' @description finds roots in complex plane.
#' @usage find_roots(x_n,roots,digits)
#' @param x_n vector
#' @param roots vector
#' @param digits number of significant digits till calculation stops.
#' @examples
#' #######
#' # seeds
#' seeds <- expand.grid(seq(-1,1, length.out = 20),
#'                       seq(-1,1, length.out = 20))
#' seeds <- complex(real = seeds$Var1, imaginary = seeds$Var2)
#'
#' f <- function(x) 1 - x + x^2 + x^5
#' f_ableitung <- function(x) -1 + 2*x + 5*x^4
#'
#' f1 <- polynom::polynomial(coef = c(-0.2,-1,1,0,0,1))
#'
#' #######
#' x_n <- seeds|>
#'   lapply(function(x){
#'   x_n <- 1:100
#'   x_n[1] <- x
#'   for( i in 2:length(x_n)) {
#'     x_n[i] <- x_n[i-1]-(f(x_n[i-1])/f_ableitung(x_n[i-1]))
#'   }
#' return(x_n)
#' })
#' x_n[[1]]|>find_roots(summary(f1)$zeros,6)
#' @export
NULL

#' find_roots_v2
#'
#' @name find_roots_v2
#' @title find_roots_v2
#' @description finds roots in complex plane.
#' @usage find_roots_v2(x_n,roots,digits)
#' @param x_n vector
#' @param roots vector
#' @param digits number of significant digits till calculation stops.
#' @examples
#' #######
#' # seeds
#' seeds <- expand.grid(seq(-1,1, length.out = 20),
#'                       seq(-1,1, length.out = 20))
#' seeds <- complex(real = seeds$Var1, imaginary = seeds$Var2)
#'
#' f <- function(x) 1 - x + x^2 + x^5
#' f_ableitung <- function(x) -1 + 2*x + 5*x^4
#'
#' f1 <- polynom::polynomial(coef = c(-0.2,-1,1,0,0,1))
#'
#' #######
#' x_n <- seeds|>
#'   lapply(function(x){
#'   x_n <- 1:100
#'   x_n[1] <- x
#'   for( i in 2:length(x_n)) {
#'     x_n[i] <- x_n[i-1]-(f(x_n[i-1])/f_ableitung(x_n[i-1]))
#'   }
#' return(x_n)
#' })
#' x_n[[1]]|>find_roots_v2(summary(f1)$zeros,6)
#' @export
NULL

#'
#' @name calc_it
#' @title calc_it
#' @description Berechntet die Funktionswerte eines Polynoms für gegebenen Vektor.
#' @usage calc_it(seeds, poly, poly_, poly_roots, c_calculation_depth, digits)
#' @param seeds complex vector
#' @param poly numeric vector  # polynom coefficients
#' @param poly_ numeric vector # derivative coefficients of the polynom => deriv(poly)
#' @param poly_roots complex roots vector # roots of the polynom => solve(poly)
#' @param c_calculation_depth #how many iterrations steps (depth of calculation)
#' @param digits how many decimal digit till calculation stop
#' @examples polynom <-polynom::polynomial(coef = c(-0.2,-1,1,0,0,1))
#' @examples roots <- solve(polynom)
#' @examples seeds <- expand.grid(seq(-2,2, length.out = 200),seq(-2,2, length.out = 200))
#' @examples seeds <- complex(real = seeds$Var1, imaginary = seeds$Var2)
#' @examples calc_it(seeds, polynom, deriv(polynom), roots,100,6)
#' @export
NULL

#'
#' @name calc_it_V2
#' @title calc_it_V2
#' @description Berechntet die Funktionswerte eines Polynoms für gegebenen Vektor.
#' @usage calc_it_V2(seeds,poly_roots,c_calculation_depth,digits)
#' @param seeds complex vector
#' @param poly_roots complex roots vector # roots of the polynom => solve(poly)
#' @param c_calculation_depth #how many iterrations steps (depth of calculation)
#' @param digits how many decimal digit till calculation stop
#' @examples polynom <-polynom::polynomial(coef = c(-0.2,-1,1,0,0,1))
#' @examples roots <- solve(polynom)
#' @examples seeds <- expand.grid(seq(-2,2, length.out = 200),seq(-2,2, length.out = 200))
#' @examples seeds <- complex(real = seeds$Var1, imaginary = seeds$Var2)
#' @examples calc_it_V2(seeds,roots,100,6)
#' @export
NULL

#'
#' @name calc_it_V3
#' @title calc_it_V3
#' @description Berechntet die Funktionswerte eines Polynoms für gegebenen Vektor.
#' @usage calc_it_V3(seeds,poly_roots,c_calculation_depth,digits)
#' @param seeds complex vector
#' @param poly_roots complex roots vector # roots of the polynom => solve(poly)
#' @param c_calculation_depth #how many iterrations steps (depth of calculation)
#' @param digits how many decimal digit till calculation stop
#' @examples polynom <-polynom::polynomial(coef = c(-0.2,-1,1,0,0,1))
#' @examples roots <- solve(polynom)
#' @examples seeds <- expand.grid(seq(-2,2, length.out = 200),seq(-2,2, length.out = 200))
#' @examples seeds <- complex(real = seeds$Var1, imaginary = seeds$Var2)
#' @examples calc_it_V3(seeds, roots, 100,6)
#' @export
NULL

f_ableitung <- function(x) {
    .Call(`_slvwagner_f_ableitung`, x)
}

f <- function(x) {
    .Call(`_slvwagner_f`, x)
}

f_vector <- function(x) {
    .Call(`_slvwagner_f_vector`, x)
}

f_ableitung_vector <- function(x) {
    .Call(`_slvwagner_f_ableitung_vector`, x)
}

function_calc_complex <- function(x, poly) {
    .Call(`_slvwagner_function_calc_complex`, x, poly)
}

vector_function_calc_complex <- function(x, poly) {
    .Call(`_slvwagner_vector_function_calc_complex`, x, poly)
}

find_roots <- function(x_n, roots, digits) {
    .Call(`_slvwagner_find_roots`, x_n, roots, digits)
}

find_roots_v2 <- function(x_n, roots, digits) {
    .Call(`_slvwagner_find_roots_v2`, x_n, roots, digits)
}

calc_it <- function(seeds, poly, poly_, poly_roots, c_calculation_depth, digits) {
    .Call(`_slvwagner_calc_it`, seeds, poly, poly_, poly_roots, c_calculation_depth, digits)
}

calc_it_V2 <- function(seeds, poly_roots, c_calculation_depth, digits) {
    .Call(`_slvwagner_calc_it_V2`, seeds, poly_roots, c_calculation_depth, digits)
}

calc_it_V3 <- function(seeds, poly_roots, c_calculation_depth, digits) {
    .Call(`_slvwagner_calc_it_V3`, seeds, poly_roots, c_calculation_depth, digits)
}

#' calc_roots_from_seeds_C
#' @name calc_roots_from_seeds_C
#' @title calc_roots_from_seeds_C
#' @description Create Student data frame.
#' @param seeds seeds
#' @param roots roots from polynom equation
#' @param poly polynomial coefficients
#' @examples
#' library(Rcpp)
#' df <- expand.grid(re = seq(0,10,0.1), im = seq(-10,0,0.1))
#' seeds <- complex(df$re,df$im)
#' calc_roots_from_seeds_C(seeds, c(0.2,2.5,3+1i), 1:10)
#' @export
NULL

#' expandGridComplex
#' @name expandGridComplex
#' @title expandGridComplex
#' @description
#' Create Student data frame with all possible variants of a complex vector.
#' @param x complex vector
#' @param epsilon consider the imaginary value as zero if smaller then \code{epsilon}
#' @return
#' returns a complex vector
#' @examples
#' expandGridComplex(complex(real = 1:100, imag = rnorm(100)))
#' @export
NULL

calc_roots_from_seeds_C <- function(seeds, roots, poly) {
    .Call(`_slvwagner_calc_roots_from_seeds_C`, seeds, roots, poly)
}

expandGridComplex <- function(x, epsilon = 1e-10) {
    .Call(`_slvwagner_expandGridComplex`, x, epsilon)
}

